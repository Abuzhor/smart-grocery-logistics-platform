#!/usr/bin/env python3
"""
Bootstrap GitHub Projects v2 Board and Issues

This script creates a GitHub Projects v2 board with custom fields and status columns,
creates/updates all 40 issues from issues.json, and adds them to the project.

Usage:
    export GH_TOKEN=<your-github-token>
    python3 scripts/planning/bootstrap_github.py

Requirements:
    - Python 3.7+
    - requests library (pip install requests)
    - GH_TOKEN environment variable set
    - issues.json file (generated by generate_issues_json.py)
"""

import os
import sys
import json
import requests
import time
from pathlib import Path
from typing import Dict, List, Optional, Any

# Configuration
REPO_OWNER = "Abuzhor"
REPO_NAME = "smart-grocery-logistics-platform"
PROJECT_TITLE = "Smart Grocery Logistics Platform - Execution Board"
PROJECT_DESCRIPTION = """
Execution board for tracking all phases of the Smart Grocery Logistics Platform development.
Source: docs/notion-export/** → GitHub Issues via PHASE 0 bootstrap.
"""

# Paths
SCRIPT_DIR = Path(__file__).parent
CONFIG_PATH = SCRIPT_DIR / "config.json"
ISSUES_PATH = SCRIPT_DIR / "issues.json"

# Color codes for output
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color

def print_color(color: str, message: str):
    """Print colored message"""
    print(f"{color}{message}{Colors.NC}")

def print_header(message: str):
    """Print section header"""
    print_color(Colors.BLUE, "=" * 60)
    print_color(Colors.BLUE, message)
    print_color(Colors.BLUE, "=" * 60)
    print()

def get_github_token() -> str:
    """Get GitHub token from environment"""
    token = os.environ.get('GH_TOKEN') or os.environ.get('GITHUB_TOKEN')
    if not token:
        print_color(Colors.RED, "Error: GH_TOKEN or GITHUB_TOKEN environment variable not set")
        sys.exit(1)
    return token

def check_dependencies():
    """Check required dependencies"""
    try:
        import requests
    except ImportError:
        print_color(Colors.RED, "Error: 'requests' library not installed")
        print_color(Colors.RED, "Install with: pip install requests")
        sys.exit(1)

class GitHubGraphQLClient:
    """GitHub GraphQL API client"""
    
    def __init__(self, token: str):
        self.token = token
        self.endpoint = "https://api.github.com/graphql"
        self.headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }
    
    def query(self, query: str, variables: Optional[Dict] = None) -> Dict:
        """Execute GraphQL query"""
        payload = {"query": query}
        if variables:
            payload["variables"] = variables
        
        response = requests.post(
            self.endpoint,
            headers=self.headers,
            json=payload
        )
        
        if response.status_code != 200:
            print_color(Colors.RED, f"GraphQL request failed: {response.status_code}")
            print_color(Colors.RED, response.text)
            raise Exception(f"GraphQL HTTP error: {response.status_code}")
        
        result = response.json()
        
        if "errors" in result:
            # For certain queries (like checking if org/user exists), we want to handle gracefully
            error_messages = [e.get("message", "") for e in result["errors"]]
            if any("Could not resolve" in msg for msg in error_messages):
                # This is expected when checking if org/user exists
                raise Exception(f"GraphQL resolution error: {error_messages[0]}")
            else:
                # Other errors should be printed and exit
                print_color(Colors.RED, "GraphQL errors:")
                print_color(Colors.RED, json.dumps(result["errors"], indent=2))
                raise Exception("GraphQL query failed")
        
        return result.get("data", {})


class GitHubRESTClient:
    """GitHub REST API client"""
    
    def __init__(self, token: str, owner: str, repo: str):
        self.token = token
        self.owner = owner
        self.repo = repo
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"Bearer {token}",
            "Accept": "application/vnd.github.v3+json",
            "Content-Type": "application/json"
        }
    
    def get(self, path: str, params: Optional[Dict] = None) -> Any:
        """Execute GET request"""
        response = requests.get(
            f"{self.base_url}{path}",
            headers=self.headers,
            params=params or {}
        )
        response.raise_for_status()
        return response.json()
    
    def post(self, path: str, data: Dict) -> Any:
        """Execute POST request"""
        response = requests.post(
            f"{self.base_url}{path}",
            headers=self.headers,
            json=data
        )
        response.raise_for_status()
        return response.json()
    
    def patch(self, path: str, data: Dict) -> Any:
        """Execute PATCH request"""
        response = requests.patch(
            f"{self.base_url}{path}",
            headers=self.headers,
            json=data
        )
        response.raise_for_status()
        return response.json()
    
    def get_all_issues(self) -> List[Dict]:
        """Get all issues (open and closed) with pagination"""
        issues = []
        page = 1
        per_page = 100
        
        while True:
            batch = self.get(
                f"/repos/{self.owner}/{self.repo}/issues",
                params={"state": "all", "per_page": per_page, "page": page}
            )
            if not batch:
                break
            issues.extend(batch)
            if len(batch) < per_page:
                break
            page += 1
            time.sleep(0.1)  # Rate limit courtesy
        
        return issues
    
    def get_milestones(self) -> Dict[str, int]:
        """Get all milestones and return mapping of title to number"""
        milestones = self.get(f"/repos/{self.owner}/{self.repo}/milestones", params={"state": "all"})
        return {m["title"]: m["number"] for m in milestones}
    
    def create_issue(self, title: str, body: str, labels: List[str], milestone: Optional[int] = None) -> Dict:
        """Create a new issue"""
        data = {
            "title": title,
            "body": body,
            "labels": labels
        }
        if milestone:
            data["milestone"] = milestone
        
        return self.post(f"/repos/{self.owner}/{self.repo}/issues", data)
    
    def update_issue(self, issue_number: int, body: str, labels: List[str], milestone: Optional[int] = None) -> Dict:
        """Update an existing issue"""
        data = {
            "body": body,
            "labels": labels
        }
        if milestone:
            data["milestone"] = milestone
        
        return self.patch(f"/repos/{self.owner}/{self.repo}/issues/{issue_number}", data)

def get_repository_id(client: GitHubGraphQLClient, owner: str, name: str) -> str:
    """Get repository node ID"""
    query = """
    query($owner: String!, $name: String!) {
      repository(owner: $owner, name: $name) {
        id
      }
    }
    """
    
    result = client.query(query, {"owner": owner, "name": name})
    return result["repository"]["id"]

def get_organization_id(client: GitHubGraphQLClient, login: str) -> Optional[str]:
    """Get organization node ID, returns None if not found"""
    query = """
    query($login: String!) {
      organization(login: $login) {
        id
      }
    }
    """
    
    try:
        result = client.query(query, {"login": login})
        return result.get("organization", {}).get("id")
    except:
        return None

def get_user_id(client: GitHubGraphQLClient, login: str) -> Optional[str]:
    """Get user node ID, returns None if not found"""
    query = """
    query($login: String!) {
      user(login: $login) {
        id
      }
    }
    """
    
    try:
        result = client.query(query, {"login": login})
        return result.get("user", {}).get("id")
    except:
        return None

def get_owner_id(client: GitHubGraphQLClient, login: str) -> tuple[str, str]:
    """
    Get owner ID and type (organization or user).
    Tries organization first, then falls back to user.
    Returns: (owner_id, owner_type) where owner_type is 'organization' or 'user'
    Raises: SystemExit if neither is found
    """
    # Try organization first
    owner_id = get_organization_id(client, login)
    if owner_id:
        return (owner_id, 'organization')
    
    # Fall back to user
    owner_id = get_user_id(client, login)
    if owner_id:
        return (owner_id, 'user')
    
    # Neither found
    print_color(Colors.RED, f"Error: Could not find organization or user with login '{login}'")
    sys.exit(1)

def find_existing_project(client: GitHubGraphQLClient, owner: str, title: str) -> Optional[Dict]:
    """Find existing project by title for user or organization"""
    owner_id, owner_type = get_owner_id(client, owner)
    
    if owner_type == 'organization':
        query = """
        query($ownerId: ID!, $first: Int!) {
          node(id: $ownerId) {
            ... on Organization {
              projectsV2(first: $first) {
                nodes {
                  id
                  number
                  title
                  url
                }
              }
            }
          }
        }
        """
    else:  # user
        query = """
        query($ownerId: ID!, $first: Int!) {
          node(id: $ownerId) {
            ... on User {
              projectsV2(first: $first) {
                nodes {
                  id
                  number
                  title
                  url
                }
              }
            }
          }
        }
        """
    
    result = client.query(query, {"ownerId": owner_id, "first": 100})
    projects = result.get("node", {}).get("projectsV2", {}).get("nodes", [])
    
    for project in projects:
        if project["title"] == title:
            return project
    
    return None

def create_project(client: GitHubGraphQLClient, owner: str, title: str, description: str) -> Dict:
    """Create a new GitHub Project v2 for user or organization"""
    owner_id, owner_type = get_owner_id(client, owner)
    
    # Note: createProjectV2 does not accept 'body' parameter
    # The description can be set later if needed via updateProjectV2
    mutation = """
    mutation($ownerId: ID!, $title: String!) {
      createProjectV2(input: {ownerId: $ownerId, title: $title}) {
        projectV2 {
          id
          number
          title
          url
        }
      }
    }
    """
    
    result = client.query(mutation, {
        "ownerId": owner_id,
        "title": title
    })
    
    project = result["createProjectV2"]["projectV2"]
    print_color(Colors.GREEN, f"  ✓ Created project for {owner_type}: {owner}")
    
    return project

def get_project_fields(client: GitHubGraphQLClient, project_id: str) -> List[Dict]:
    """Get existing fields for a project"""
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          fields(first: 20) {
            nodes {
              ... on ProjectV2Field {
                id
                name
                dataType
              }
              ... on ProjectV2SingleSelectField {
                id
                name
                dataType
                options {
                  id
                  name
                }
              }
            }
          }
        }
      }
    }
    """
    
    result = client.query(query, {"projectId": project_id})
    return result["node"]["fields"]["nodes"]

def create_single_select_field(client: GitHubGraphQLClient, project_id: str, name: str, options: List[str]) -> Dict:
    """Create a single select custom field"""
    mutation = """
    mutation($projectId: ID!, $name: String!, $options: [ProjectV2SingleSelectFieldOptionInput!]!) {
      createProjectV2Field(input: {
        projectId: $projectId,
        dataType: SINGLE_SELECT,
        name: $name,
        singleSelectOptions: $options
      }) {
        projectV2Field {
          ... on ProjectV2SingleSelectField {
            id
            name
            options {
              id
              name
            }
          }
        }
      }
    }
    """
    
    # CRITICAL: description cannot be null in ProjectV2SingleSelectFieldOptionInput
    option_inputs = [{"name": opt, "color": "GRAY", "description": ""} for opt in options]
    
    result = client.query(mutation, {
        "projectId": project_id,
        "name": name,
        "options": option_inputs
    })
    
    return result["createProjectV2Field"]["projectV2Field"]

def create_text_field(client: GitHubGraphQLClient, project_id: str, name: str) -> Dict:
    """Create a text custom field"""
    mutation = """
    mutation($projectId: ID!, $name: String!) {
      createProjectV2Field(input: {
        projectId: $projectId,
        dataType: TEXT,
        name: $name
      }) {
        projectV2Field {
          ... on ProjectV2Field {
            id
            name
          }
        }
      }
    }
    """
    
    result = client.query(mutation, {
        "projectId": project_id,
        "name": name
    })
    
    return result["createProjectV2Field"]["projectV2Field"]

def add_single_select_options(client: GitHubGraphQLClient, project_id: str, field_id: str, options: List[str]) -> Dict:
    """Add new options to an existing single select field (idempotent)"""
    mutation = """
    mutation($projectId: ID!, $fieldId: ID!, $options: [ProjectV2SingleSelectFieldOptionInput!]!) {
      updateProjectV2Field(input: {
        projectId: $projectId,
        fieldId: $fieldId,
        singleSelectOptions: $options
      }) {
        projectV2Field {
          ... on ProjectV2SingleSelectField {
            id
            name
            options {
              id
              name
            }
          }
        }
      }
    }
    """
    
    # CRITICAL: description cannot be null in ProjectV2SingleSelectFieldOptionInput
    option_inputs = [{"name": opt, "color": "GRAY", "description": ""} for opt in options]
    
    result = client.query(mutation, {
        "projectId": project_id,
        "fieldId": field_id,
        "options": option_inputs
    })
    
    return result["updateProjectV2Field"]["projectV2Field"]

def get_repository_issues(client: GitHubGraphQLClient, owner: str, repo: str, limit: int = 100) -> List[Dict]:
    """Get repository issues"""
    query = """
    query($owner: String!, $repo: String!, $first: Int!) {
      repository(owner: $owner, name: $repo) {
        issues(first: $first, orderBy: {field: CREATED_AT, direction: DESC}) {
          nodes {
            id
            number
            title
            url
          }
        }
      }
    }
    """
    
    result = client.query(query, {"owner": owner, "repo": repo, "first": limit})
    return result["repository"]["issues"]["nodes"]

def add_issue_to_project(client: GitHubGraphQLClient, project_id: str, issue_id: str) -> Dict:
    """Add an issue to a project"""
    mutation = """
    mutation($projectId: ID!, $contentId: ID!) {
      addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
        item {
          id
        }
      }
    }
    """
    
    result = client.query(mutation, {
        "projectId": project_id,
        "contentId": issue_id
    })
    
    return result["addProjectV2ItemById"]["item"]


def get_project_items(client: GitHubGraphQLClient, project_id: str) -> List[Dict]:
    """Get all items in a project"""
    query = """
    query($projectId: ID!) {
      node(id: $projectId) {
        ... on ProjectV2 {
          items(first: 100) {
            nodes {
              id
              content {
                ... on Issue {
                  id
                  number
                  title
                }
              }
            }
          }
        }
      }
    }
    """
    
    result = client.query(query, {"projectId": project_id})
    return result["node"]["items"]["nodes"]


def set_project_field_value(client: GitHubGraphQLClient, project_id: str, item_id: str, field_id: str, value: Any) -> bool:
    """Set a single select or text field value on a project item"""
    
    # For single select fields, value is the option ID
    # For text fields, value is the text string
    if isinstance(value, str) and not value.startswith("PVTSSF"):  # Not an option ID
        # Text field
        mutation = """
        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {
          updateProjectV2ItemFieldValue(input: {
            projectId: $projectId,
            itemId: $itemId,
            fieldId: $fieldId,
            value: {text: $value}
          }) {
            projectV2Item {
              id
            }
          }
        }
        """
        result = client.query(mutation, {
            "projectId": project_id,
            "itemId": item_id,
            "fieldId": field_id,
            "value": value
        })
    else:
        # Single select field
        mutation = """
        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
          updateProjectV2ItemFieldValue(input: {
            projectId: $projectId,
            itemId: $itemId,
            fieldId: $fieldId,
            value: {singleSelectOptionId: $optionId}
          }) {
            projectV2Item {
              id
            }
          }
        }
        """
        result = client.query(mutation, {
            "projectId": project_id,
            "itemId": item_id,
            "fieldId": field_id,
            "optionId": value
        })
    
    return True


def get_field_option_id(fields: List[Dict], field_name: str, option_name: str) -> Optional[str]:
    """Get the option ID for a single select field"""
    for field in fields:
        if field["name"] == field_name and "options" in field:
            for option in field["options"]:
                if option["name"] == option_name:
                    return option["id"]
    return None

def main():
    """Main execution"""
    print_header(f"GitHub Bootstrap for {REPO_OWNER}/{REPO_NAME}")
    
    # Check dependencies
    check_dependencies()
    
    # Get GitHub token
    token = get_github_token()
    graphql_client = GitHubGraphQLClient(token)
    rest_client = GitHubRESTClient(token, REPO_OWNER, REPO_NAME)
    
    print_color(Colors.GREEN, "✓ GitHub clients initialized")
    print()
    
    # Load configuration
    if not CONFIG_PATH.exists():
        print_color(Colors.RED, f"Error: config.json not found at {CONFIG_PATH}")
        sys.exit(1)
    
    if not ISSUES_PATH.exists():
        print_color(Colors.RED, f"Error: issues.json not found at {ISSUES_PATH}")
        print_color(Colors.RED, "Run: python3 scripts/planning/generate_issues_json.py")
        sys.exit(1)
    
    with open(ISSUES_PATH, 'r', encoding='utf-8') as f:
        issues_data = json.load(f)
    
    print_color(Colors.GREEN, f"✓ Loaded {len(issues_data)} issue definitions from issues.json")
    print()
    
    # Get milestones
    print("Fetching milestones...")
    milestones = rest_client.get_milestones()
    print_color(Colors.GREEN, f"✓ Found {len(milestones)} milestones")
    for title in sorted(milestones.keys()):
        print(f"  - {title}")
    print()
    
    # Get existing issues
    print("Fetching existing issues...")
    existing_issues = rest_client.get_all_issues()
    existing_by_title = {issue["title"]: issue for issue in existing_issues}
    print_color(Colors.GREEN, f"✓ Found {len(existing_issues)} existing issues")
    print()
    
    # Upsert issues
    print_header("Creating/Updating Issues")
    
    created_issues = []
    updated_issues = []
    skipped_issues = []
    warnings = []
    
    for issue_def in issues_data:
        title = issue_def["title"]
        body = issue_def["body"]
        labels = issue_def["labels"]
        milestone_title = issue_def.get("milestone")
        
        # Get milestone number
        milestone_number = None
        if milestone_title and milestone_title in milestones:
            milestone_number = milestones[milestone_title]
        elif milestone_title:
            warnings.append(f"Milestone not found: {milestone_title} for issue '{title}'")
        
        try:
            if title in existing_by_title:
                # Update existing issue
                existing = existing_by_title[title]
                issue_number = existing["number"]
                
                # Check if update is needed
                needs_update = False
                if existing["body"] != body:
                    needs_update = True
                existing_labels = {label["name"] for label in existing.get("labels", [])}
                if existing_labels != set(labels):
                    needs_update = True
                existing_milestone = existing.get("milestone", {}).get("number") if existing.get("milestone") else None
                if existing_milestone != milestone_number:
                    needs_update = True
                
                if needs_update:
                    rest_client.update_issue(issue_number, body, labels, milestone_number)
                    print_color(Colors.YELLOW, f"  ↻ Updated issue #{issue_number}: {title[:60]}...")
                    updated_issues.append((issue_number, title))
                else:
                    print_color(Colors.YELLOW, f"  = Skipped (no changes) #{issue_number}: {title[:60]}...")
                    skipped_issues.append((issue_number, title))
                
                # Store issue data for project sync
                issue_def["_github_number"] = issue_number
                issue_def["_github_id"] = existing["node_id"]
            else:
                # Create new issue
                created = rest_client.create_issue(title, body, labels, milestone_number)
                issue_number = created["number"]
                print_color(Colors.GREEN, f"  ✓ Created issue #{issue_number}: {title[:60]}...")
                created_issues.append((issue_number, title))
                
                # Store issue data for project sync
                issue_def["_github_number"] = issue_number
                issue_def["_github_id"] = created["node_id"]
            
            time.sleep(0.2)  # Rate limit courtesy
        
        except Exception as e:
            warnings.append(f"Failed to upsert issue '{title}': {str(e)}")
            print_color(Colors.RED, f"  ✗ Error with issue '{title}': {str(e)}")
    
    print()
    print_color(Colors.GREEN, f"✓ Issue upsert complete")
    print(f"  Created: {len(created_issues)}")
    print(f"  Updated: {len(updated_issues)}")
    print(f"  Skipped (no changes): {len(skipped_issues)}")
    print()
    
    # Create or find project
    print_header("Setting up Projects v2 Board")
    
    # Detect owner type
    print(f"Detecting owner type for '{REPO_OWNER}'...")
    owner_id, owner_type = get_owner_id(graphql_client, REPO_OWNER)
    print_color(Colors.GREEN, f"✓ Owner '{REPO_OWNER}' is a {owner_type}")
    print()
    
    print("Checking for existing project...")
    existing_project = find_existing_project(graphql_client, REPO_OWNER, PROJECT_TITLE)
    
    if existing_project:
        print_color(Colors.YELLOW, f"  ↻ Project already exists: {existing_project['title']}")
        print_color(Colors.YELLOW, f"     {existing_project['url']}")
        project = existing_project
    else:
        print("Creating new project...")
        project = create_project(graphql_client, REPO_OWNER, PROJECT_TITLE, PROJECT_DESCRIPTION)
        print_color(Colors.GREEN, f"  ✓ Created project: {project['title']}")
        print_color(Colors.GREEN, f"     {project['url']}")
    
    project_id = project["id"]
    project_url = project["url"]
    print()
    
    # Create custom fields (idempotent with option checking)
    print("Setting up custom fields...")
    existing_fields = get_project_fields(graphql_client, project_id)
    existing_field_names = {field["name"] for field in existing_fields}
    
    # Phase field
    phase_options = ["PHASE 0", "PHASE 1", "PHASE 2", "PHASE 3", "PHASE 4"]
    if "Phase" not in existing_field_names:
        create_single_select_field(graphql_client, project_id, "Phase", phase_options)
        print_color(Colors.GREEN, "  ✓ Created field: Phase")
        # Refresh fields
        existing_fields = get_project_fields(graphql_client, project_id)
    else:
        # Check if all options exist, add missing ones
        phase_field = next(f for f in existing_fields if f["name"] == "Phase")
        existing_options = {opt["name"] for opt in phase_field.get("options", [])}
        missing_options = [opt for opt in phase_options if opt not in existing_options]
        if missing_options:
            # Add missing options
            all_options = list(existing_options) + missing_options
            add_single_select_options(graphql_client, project_id, phase_field["id"], all_options)
            print_color(Colors.YELLOW, f"  ↻ Field exists: Phase (added {len(missing_options)} missing options)")
            existing_fields = get_project_fields(graphql_client, project_id)
        else:
            print_color(Colors.YELLOW, "  ↻ Field exists: Phase")
    
    # Domain field
    domain_options = [
        "Catalog", "Inventory", "Ordering", "Fulfillment", "Routing",
        "Partner", "Workforce", "Operations", "Compliance", "Platform"
    ]
    if "Domain" not in existing_field_names:
        create_single_select_field(graphql_client, project_id, "Domain", domain_options)
        print_color(Colors.GREEN, "  ✓ Created field: Domain")
        existing_fields = get_project_fields(graphql_client, project_id)
    else:
        # Check if all options exist, add missing ones
        domain_field = next(f for f in existing_fields if f["name"] == "Domain")
        existing_options = {opt["name"] for opt in domain_field.get("options", [])}
        missing_options = [opt for opt in domain_options if opt not in existing_options]
        if missing_options:
            all_options = list(existing_options) + missing_options
            add_single_select_options(graphql_client, project_id, domain_field["id"], all_options)
            print_color(Colors.YELLOW, f"  ↻ Field exists: Domain (added {len(missing_options)} missing options)")
            existing_fields = get_project_fields(graphql_client, project_id)
        else:
            print_color(Colors.YELLOW, "  ↻ Field exists: Domain")
    
    # Priority field
    priority_options = ["Critical", "High", "Medium", "Low"]
    if "Priority" not in existing_field_names:
        create_single_select_field(graphql_client, project_id, "Priority", priority_options)
        print_color(Colors.GREEN, "  ✓ Created field: Priority")
        existing_fields = get_project_fields(graphql_client, project_id)
    else:
        # Check if all options exist, add missing ones
        priority_field = next(f for f in existing_fields if f["name"] == "Priority")
        existing_options = {opt["name"] for opt in priority_field.get("options", [])}
        missing_options = [opt for opt in priority_options if opt not in existing_options]
        if missing_options:
            all_options = list(existing_options) + missing_options
            add_single_select_options(graphql_client, project_id, priority_field["id"], all_options)
            print_color(Colors.YELLOW, f"  ↻ Field exists: Priority (added {len(missing_options)} missing options)")
            existing_fields = get_project_fields(graphql_client, project_id)
        else:
            print_color(Colors.YELLOW, "  ↻ Field exists: Priority")
    
    # Notion Reference field
    if "Notion Reference" not in existing_field_names:
        create_text_field(graphql_client, project_id, "Notion Reference")
        print_color(Colors.GREEN, "  ✓ Created field: Notion Reference")
        existing_fields = get_project_fields(graphql_client, project_id)
    else:
        print_color(Colors.YELLOW, "  ↻ Field exists: Notion Reference")
    
    print()
    
    # Get project items
    print("Fetching project items...")
    project_items = get_project_items(graphql_client, project_id)
    items_by_issue_number = {}
    for item in project_items:
        if item.get("content") and "number" in item["content"]:
            items_by_issue_number[item["content"]["number"]] = item
    
    print_color(Colors.GREEN, f"✓ Found {len(project_items)} items in project")
    print()
    
    # Add issues to project and set field values
    print_header("Adding Issues to Project and Setting Fields")
    
    added_count = 0
    field_update_count = 0
    
    # Get field IDs
    field_ids = {field["name"]: field["id"] for field in existing_fields}
    
    for issue_def in issues_data:
        if "_github_number" not in issue_def:
            continue  # Issue creation failed
        
        issue_number = issue_def["_github_number"]
        issue_id = issue_def["_github_id"]
        title = issue_def["title"]
        
        try:
            # Add to project if not already there
            if issue_number not in items_by_issue_number:
                item = add_issue_to_project(graphql_client, project_id, issue_id)
                item_id = item["id"]
                print_color(Colors.GREEN, f"  ✓ Added #{issue_number} to project: {title[:50]}...")
                added_count += 1
                time.sleep(0.2)
            else:
                item_id = items_by_issue_number[issue_number]["id"]
                print_color(Colors.YELLOW, f"  ↻ Already in project #{issue_number}: {title[:50]}...")
            
            # Set field values
            project_meta = issue_def.get("project", {})
            
            # Set Phase
            if project_meta.get("phase") and "Phase" in field_ids:
                option_id = get_field_option_id(existing_fields, "Phase", project_meta["phase"])
                if option_id:
                    set_project_field_value(graphql_client, project_id, item_id, field_ids["Phase"], option_id)
                    field_update_count += 1
                    time.sleep(0.1)
            
            # Set Domain
            if project_meta.get("domain") and "Domain" in field_ids:
                option_id = get_field_option_id(existing_fields, "Domain", project_meta["domain"])
                if option_id:
                    set_project_field_value(graphql_client, project_id, item_id, field_ids["Domain"], option_id)
                    field_update_count += 1
                    time.sleep(0.1)
            
            # Set Priority
            if project_meta.get("priority") and "Priority" in field_ids:
                option_id = get_field_option_id(existing_fields, "Priority", project_meta["priority"])
                if option_id:
                    set_project_field_value(graphql_client, project_id, item_id, field_ids["Priority"], option_id)
                    field_update_count += 1
                    time.sleep(0.1)
            
            # Set Notion Reference
            if project_meta.get("notion_reference") and "Notion Reference" in field_ids:
                set_project_field_value(graphql_client, project_id, item_id, field_ids["Notion Reference"], project_meta["notion_reference"])
                field_update_count += 1
                time.sleep(0.1)
        
        except Exception as e:
            warnings.append(f"Failed to add/update project item for issue #{issue_number}: {str(e)}")
            print_color(Colors.RED, f"  ✗ Error with issue #{issue_number}: {str(e)}")
    
    print()
    print_color(Colors.GREEN, f"✓ Project sync complete")
    print(f"  Added to project: {added_count}")
    print(f"  Field values set: {field_update_count}")
    print()
    
    # Summary
    print_header("Summary")
    print_color(Colors.BLUE, f"Repository: {REPO_OWNER}/{REPO_NAME}")
    print_color(Colors.BLUE, f"Owner Type: {owner_type}")
    print_color(Colors.BLUE, f"Project: {project['title']}")
    print_color(Colors.BLUE, f"Project URL: {project_url}")
    print()
    print_color(Colors.GREEN, f"Issues:")
    print(f"  Created: {len(created_issues)}")
    print(f"  Updated: {len(updated_issues)}")
    print(f"  Skipped (no changes): {len(skipped_issues)}")
    print(f"  Total in repo: {len(created_issues) + len(updated_issues) + len(skipped_issues)}")
    print()
    print_color(Colors.GREEN, f"Project Board:")
    print(f"  Added to project: {added_count}")
    print(f"  Field values updated: {field_update_count}")
    print()
    
    if created_issues:
        print_color(Colors.GREEN, f"Created {len(created_issues)} issues:")
        for num, title in created_issues[:10]:  # Show first 10
            print(f"  #{num}: {title[:70]}")
        if len(created_issues) > 10:
            print(f"  ... and {len(created_issues) - 10} more")
        print()
    
    if updated_issues:
        print_color(Colors.YELLOW, f"Updated {len(updated_issues)} issues:")
        for num, title in updated_issues[:10]:
            print(f"  #{num}: {title[:70]}")
        if len(updated_issues) > 10:
            print(f"  ... and {len(updated_issues) - 10} more")
        print()
    
    if warnings:
        print_color(Colors.YELLOW, f"Warnings ({len(warnings)}):")
        for warning in warnings[:5]:
            print(f"  - {warning}")
        if len(warnings) > 5:
            print(f"  ... and {len(warnings) - 5} more")
        print()
    
    print_color(Colors.GREEN, "✓ Bootstrap complete!")
    print()
    print_color(Colors.BLUE, "Next Steps:")
    print("1. Visit the project board to view all issues")
    print(f"   {project_url}")
    print("2. Configure status column workflows if needed")
    print("3. Start working on issues!")
    print()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print()
        print_color(Colors.YELLOW, "Interrupted by user")
        sys.exit(1)
    except Exception as e:
        print()
        print_color(Colors.RED, f"Error: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
